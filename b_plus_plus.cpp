#include <iostream>  
#include <vector>    // Для работы с динамическими массивами
#include <random>    // Для генерации случайных чисел
#include <algorithm> // Для алгоритмов (сортировка, поиск)
#include <fstream>   // Для работы с файлами

using namespace std; // Использование стандартного пространства имен

// Структура узла B-дерева
struct BTreeNode {
    vector<int> keys;            // Вектор ключей в узле
    vector<BTreeNode*> children; // Вектор указателей на дочерние узлы
    bool isLeaf;                 // Флаг: является ли узел листом
    int order;                   // Порядок B-дерева (максимальное количество потомков)

    // Функция инициализации узла (заменяет конструктор)
    // m - порядок дерева, leaf - является ли узел листом
    void initialize(int m, bool leaf) {
        order = m;               // Устанавливаем порядок дерева
        isLeaf = leaf;           // Устанавливаем тип узла (лист или внутренний)
        keys.clear();            // Очищаем вектор ключей (на всякий случай)
        children.clear();        // Очищаем вектор потомков (на всякий случай)
        keys.reserve(m - 1);     // Резервируем место для максимум m-1 ключей
        children.reserve(m);     // Резервируем место для максимум m потомков
    }

    // Поиск позиции ключа в узле
    int findKey(int key) {
        int idx = 0;             // Начинаем с первой позиции
        // Ищем позицию, где должен находиться ключ
        while (idx < keys.size() && keys[idx] < key) {
            ++idx;               // Переходим к следующей позиции
        }
        return idx;              // Возвращаем найденную позицию
    }

    // Проверка, полон ли узел (содержит максимальное количество ключей)
    bool isFull() {
        return keys.size() == order - 1;  // Узел полон, если содержит order-1 ключей
    }

    // Проверка, имеет ли узел минимальное количество ключей
    bool hasMinKeys() {
        return keys.size() >= (order / 2) - 1;  // Минимум (order/2)-1 ключей для внутренних узлов
    }

    // Вставка ключа в неполный узел
    void insertNonFull(int key) {
        int i = keys.size() - 1; // Начинаем с последнего элемента

        if (isLeaf) {            // Если это лист
            keys.push_back(0);   // Добавляем место для нового ключа
            // Сдвигаем элементы вправо, пока не найдем место для вставки
            while (i >= 0 && keys[i] > key) {
                keys[i + 1] = keys[i];  // Сдвигаем элемент вправо
                i--;                    // Переходим к предыдущему элементу
            }
            keys[i + 1] = key;   // Вставляем ключ на найденную позицию
        } else {                 // Если это внутренний узел
            // Находим дочерний узел для вставки
            while (i >= 0 && keys[i] > key) {
                i--;             // Ищем правильного потомка
            }
            i++;                 // Переходим к найденному потомку

            // Если дочерний узел полон, разделяем его
            if (children[i]->isFull()) {
                splitChild(i, children[i]);  // Разделяем полный узел
                // После разделения проверяем, в какой части вставлять
                if (keys[i] < key) {
                    i++;         // Переходим к правой части после разделения
                }
            }
            children[i]->insertNonFull(key);  // Рекурсивно вставляем в дочерний узел
        }
    }

    // Разделение полного дочернего узла
    void splitChild(int i, BTreeNode* y) {
        int midIndex = (order - 1) / 2;  // Находим индекс среднего элемента
        
        // Создаем новый узел и инициализируем его
        BTreeNode* z = new BTreeNode();                    // Выделяем память для нового узла
        z->initialize(y->order, y->isLeaf);               // Инициализируем с теми же свойствами
        
        // Копируем правую половину ключей из y в z
        for (int j = midIndex + 1; j < y->keys.size(); j++) {
            z->keys.push_back(y->keys[j]);  // Копируем ключ в новый узел
        }

        // Если узел не лист, копируем соответствующие потомки
        if (!y->isLeaf) {
            for (int j = midIndex + 1; j < y->children.size(); j++) {
                z->children.push_back(y->children[j]);  // Копируем указатель на потомка
            }
        }

        // Уменьшаем размер исходного узла y
        y->keys.resize(midIndex);        // Оставляем только левую половину ключей
        if (!y->isLeaf) {
            y->children.resize(midIndex + 1);  // Оставляем соответствующих потомков
        }

        // Вставляем новый дочерний узел в текущий узел
        children.insert(children.begin() + i + 1, z);  // Добавляем z как правого потомка

        // Средний ключ поднимается в текущий узел
        keys.insert(keys.begin() + i, y->keys[midIndex]);  // Поднимаем средний ключ
    }

    // Поиск ключа в поддереве
    BTreeNode* search(int key) {
        int i = 0;               // Начинаем с первого ключа
        // Ищем позицию ключа в текущем узле
        while (i < keys.size() && key > keys[i]) {
            i++;                 // Переходим к следующему ключу
        }

        // Если нашли ключ в текущем узле
        if (i < keys.size() && keys[i] == key) {
            return this;         // Возвращаем указатель на текущий узел
        }

        // Если это лист и ключ не найден
        if (isLeaf) {
            return nullptr;      // Ключа нет в дереве
        }

        // Рекурсивно ищем в соответствующем дочернем узле
        return children[i]->search(key);
    }

    // Обход дерева в порядке возрастания (in-order traversal)
    void traverse() {
        int i;
        // Проходим по всем ключам в узле
        for (i = 0; i < keys.size(); i++) {
            // Если не лист, сначала обходим левого потомка
            if (!isLeaf) {
                children[i]->traverse();  // Рекурсивный обход левого поддерева
            }
            cout << keys[i] << " ";       // Выводим текущий ключ
        }

        // Если не лист, обходим последнего потомка
        if (!isLeaf) {
            children[i]->traverse();      // Рекурсивный обход правого поддерева
        }
    }

    // Вывод структуры дерева в красивом виде с использованием символов
    void printTree(string prefix = "", bool isLast = true, int childIndex = -1) {
        cout << prefix;                   // Выводим отступ
        cout << (isLast ? "└── " : "├── ");  // Выбираем символ в зависимости от позиции

        // Показываем индекс потомка если это не корень
        if (childIndex >= 0) {
            cout << "(" << childIndex << ") ";  // Номер потомка в родительском узле
        }
        
        // Выводим все ключи узла в квадратных скобках
        cout << "[";
        for (int i = 0; i < keys.size(); i++) {
            if (i > 0) cout << ", ";      // Разделяем ключи запятыми
            cout << keys[i];              // Выводим ключ
        }
        cout << "]";

        // Дополнительная информация о узле
        cout << " (ключей: " << keys.size();  // Количество ключей
        if (!isLeaf) {
            cout << ", потомков: " << children.size();  // Количество потомков
        }
        cout << ")";

        // Помечаем листовые узлы
        if (isLeaf) {
            cout << " [ЛИСТ]";            // Метка для листового узла
        }
        cout << endl;                     // Переход на новую строку

        // Рекурсивно выводим всех потомков
        if (!isLeaf) {
            for (int i = 0; i < children.size(); i++) {
                bool isLastChild = (i == children.size() - 1);  // Последний ли это потомок
                // Формируем новый отступ для потомка
                string newPrefix = prefix + (isLast ? "    " : "│   ");
                // Рекурсивно выводим потомка
                children[i]->printTree(newPrefix, isLastChild, i);
            }
        }
    }

    // Запись структуры дерева в файл (аналогично printTree)
    void writeTreeToFile(ofstream& file, string prefix = "", bool isLast = true, int childIndex = -1) {
        file << prefix;                   // Записываем отступ в файл
        file << (isLast ? "└── " : "├── ");  // Записываем символ структуры

        // Показываем индекс потомка если это не корень
        if (childIndex >= 0) {
            file << "(" << childIndex << ") ";  // Номер потомка
        }
        
        // Записываем все ключи узла
        file << "[";
        for (int i = 0; i < keys.size(); i++) {
            if (i > 0) file << ", ";      // Разделяем запятыми
            file << keys[i];              // Записываем ключ
        }
        file << "]";

        // Записываем дополнительную информацию
        file << " (ключей: " << keys.size();
        if (!isLeaf) {
            file << ", потомков: " << children.size();
        }
        file << ")";

        // Помечаем листья
        if (isLeaf) {
            file << " [ЛИСТ]";
        }
        file << endl;                     // Новая строка в файле

        // Рекурсивно записываем всех потомков
        if (!isLeaf) {
            for (int i = 0; i < children.size(); i++) {
                bool isLastChild = (i == children.size() - 1);
                string newPrefix = prefix + (isLast ? "    " : "│   ");
                children[i]->writeTreeToFile(file, newPrefix, isLastChild, i);
            }
        }
    }
};

// Структура B-дерева (без конструктора)
struct BTree {
    BTreeNode* root;  // Указатель на корень дерева
    int order;        // Порядок дерева

    // Функция инициализации B-дерева (заменяет конструктор)
    void initialize(int m) {
        order = m;        // Устанавливаем порядок дерева
        root = nullptr;   // Изначально дерево пустое
    }

    // Поиск ключа в дереве
    BTreeNode* search(int key) {
        // Если дерево пустое, возвращаем nullptr, иначе ищем в корне
        return (root == nullptr) ? nullptr : root->search(key);
    }

    // Вставка ключа с проверкой на дубликаты
    bool insert(int key) {
        // Проверяем, есть ли уже такой ключ в дереве
        if (search(key) != nullptr) {
            cout << "Ключ " << key << " уже существует в дереве! Пропускаем." << endl;
            return false;  // Ключ не был вставлен
        }

        if (root == nullptr) {  // Если дерево пустое
            // Создаем и инициализируем первый узел (корень-лист)
            root = new BTreeNode();           // Выделяем память для корня
            root->initialize(order, true);    // Инициализируем как лист
            root->keys.push_back(key);        // Добавляем ключ в корень
        } else {
            // Если корень полон, создаем новый корень
            if (root->isFull()) {
                // Создаем и инициализируем новый корень (не лист)
                BTreeNode* temp = new BTreeNode();      // Выделяем память для нового корня
                temp->initialize(order, false);        // Инициализируем как внутренний узел
                temp->children.push_back(root);        // Старый корень становится потомком
                temp->splitChild(0, root);             // Разделяем старый корень

                // Определяем, в какую часть вставлять новый ключ
                int i = 0;
                if (temp->keys[0] < key) {
                    i++;  // Вставляем в правую часть
                }
                temp->children[i]->insertNonFull(key);  // Вставляем в выбранную часть
                root = temp;  // Обновляем корень
            } else {
                root->insertNonFull(key);  // Вставляем в неполный корень
            }
        }
        return true;  // Ключ успешно вставлен
    }

    // Вывод дерева в порядке возрастания
    void traverse() {
        if (root != nullptr) {  // Если дерево не пустое
            cout << "Содержимое B-дерева: ";
            root->traverse();   // Обходим дерево начиная с корня
            cout << endl;       // Переход на новую строку
        } else {
            cout << "Дерево пустое!" << endl;  // Сообщение для пустого дерева
        }
    }

    // Вывод структуры дерева в консоль
    void printStructure() {
        if (root != nullptr) {  // Если дерево не пустое
            cout << "\nСтруктура B-дерева порядка " << order << ":" << endl;
            cout << "Корень: ";  // Выводим информацию о корне
            
            // Выводим ключи корня
            cout << "[";
            for (int i = 0; i < root->keys.size(); i++) {
                if (i > 0) cout << ", ";  // Разделяем запятыми
                cout << root->keys[i];    // Выводим ключ корня
            }
            cout << "]" << endl;
            root->printTree();  // Выводим структуру дерева
        } else {
            cout << "Дерево пустое!" << endl;  // Сообщение для пустого дерева
        }
    }

    // Вывод свойств B-дерева
    void validateProperties() {
        cout << "\n=== Свойства B-дерева порядка " << order << " ===" << endl;
        cout << "Свойство 1: Глубина всех листьев одинакова" << endl;
        cout << "Свойство 2: Узлы (кроме корня) содержат от " << (order/2)-1 << " до " << order-1 << " ключей" << endl;
        cout << "Свойство 3: Внутренние узлы (кроме корня) имеют минимум " << order/2 << " потомков" << endl;
        cout << "Свойство 4: Корень-не-лист имеет минимум 2 потомка" << endl;
        cout << "Свойство 5: Узел с n-1 ключами имеет n потомков" << endl;
        cout << "Свойство 6: Ключи в узле в порядке возрастания" << endl;
        cout << "Свойство 7: Все ключи в дереве уникальны (нет дубликатов)" << endl;
    }

};

// Главная функция программы
int main() {
    int order;    // Переменная для хранения порядка дерева
    int choice;   // Переменная для выбора пользователя
    
    // Приветствие и ввод порядка дерева
    cout << "=== Программа построения B-дерева ===" << endl;
    cout << "Введите порядок дерева (минимум 3): ";
    cin >> order;  // Читаем порядок дерева от пользователя
    
    // Проверяем корректность ввода
    if (order < 3) {
        cout << "Порядок дерева должен быть не менее 3!" << endl;
        return 1;  // Выходим с кодом ошибки
    }

    // Создаем и инициализируем B-дерево заданного порядка
    BTree tree;                // Объявляем структуру дерева
    tree.initialize(order);    // Инициализируем дерево с заданным порядком
    
    // Выводим информацию о созданном дереве
    cout << "\nСоздано B-дерево порядка " << order << endl;
    cout << "Максимум ключей в узле: " << order - 1 << endl;
    cout << "Максимум потомков: " << order << endl;
    cout << "Минимум ключей (для не-корневых узлов): " << (order/2) - 1 << endl;
    cout << "Минимум потомков (для внутренних не-корневых узлов): " << order/2 << endl;
    cout << "ВНИМАНИЕ: Дубликаты ключей не допускаются!" << endl;
    
    // Предлагаем пользователю выбрать способ заполнения
    cout << "\nВыберите способ заполнения дерева:" << endl;
    cout << "1. Случайное заполнение" << endl;
    cout << "2. Ввод значений вручную" << endl;
    cout << "Ваш выбор: ";
    cin >> choice;  // Читаем выбор пользователя

    if (choice == 1) {  // Случайное заполнение
        int count;      // Количество элементов для генерации
        cout << "Введите количество элементов для генерации: ";
        cin >> count;   // Читаем количество элементов
        
        // Проверяем корректность ввода
        if (count <= 0) {
            cout << "Количество элементов должно быть положительным!" << endl;
            return 1;   // Выходим с кодом ошибки
        }
        
        // Настраиваем генератор случайных чисел
        random_device rd;                        // Источник энтропии
        mt19937 gen(rd());                       // Генератор Mersenne Twister
        uniform_int_distribution<> dis(1, 100);  // Равномерное распределение от 1 до 100
        
        cout << "\nГенерируемые числа: ";
        int inserted = 0;  // Счетчик успешно вставленных элементов
        
        // Генерируем и вставляем случайные числа
        for (int i = 0; i < count; i++) {
            int value = dis(gen);       // Генерируем случайное число
            cout << value << " ";       // Выводим сгенерированное число
            if (tree.insert(value)) {   // Пытаемся вставить число
                inserted++;             // Увеличиваем счетчик при успешной вставке
            }
        }
        cout << endl;  // Переход на новую строку
        cout << "Успешно вставлено уникальных элементов: " << inserted << " из " << count << endl;
        
    } else if (choice == 2) {  // Ручной ввод
        int count;             // Количество элементов
        cout << "Введите количество элементов: ";
        cin >> count;          // Читаем количество элементов
        
        // Проверяем корректность ввода
        if (count <= 0) {
            cout << "Количество элементов должно быть положительным!" << endl;
            return 1;          // Выходим с кодом ошибки
        }
        
        cout << "Введите " << count << " чисел: ";
        int inserted = 0;      // Счетчик успешно вставленных элементов
        
        // Читаем и вставляем числа от пользователя
        for (int i = 0; i < count; i++) {
            int value;         // Переменная для текущего числа
            cin >> value;      // Читаем число от пользователя
            if (tree.insert(value)) {  // Пытаемся вставить число
                inserted++;    // Увеличиваем счетчик при успешной вставке
            }
        }
        cout << "Успешно вставлено уникальных элементов: " << inserted << " из " << count << endl;
    } else {  // Неверный выбор
        cout << "Неверный выбор!" << endl;
        return 1;  // Выходим с кодом ошибки
    }

    // Выводим результаты построения дерева
    cout << "\n" << string(60, '=') << endl;  // Разделительная линия
    tree.traverse();       // Выводим содержимое дерева в отсортированном порядке
    tree.printStructure(); // Выводим структуру дерева
    
    // Показываем свойства B-дерева
    tree.validateProperties();

    return 0;  // Успешное завершение программы
}


// B+ дерево
// данные хранятся только в листьях, внутренние узлы содержат только ключи для навигации
// все листья связаны в двусвязный список, что позволяет эффективно выполнять последовательное сканирование
// *двусвязный список - тип данных, где каждая узел(элемент) хранит предыдущий и следующий элемент
// ключи из листьев дублируются во внутренних узлах для навигации
// внутренние узлы компактнее, так как содержат только ключи